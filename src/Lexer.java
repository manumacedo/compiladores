import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Lexer {
	static final String validStrings = "(\"[ #-~]*\"|\'[ !#-~]*\')"; // qualquer caractere
														// entre 32 e 126 exceto
														// o 34 ("), entre aspas
														// duplas ou simples
	
	static final String openStrings = "(\"[ !#-~]*$|\'[ !#-~]*$)"; // qualquer caractere
														// entre 32 e 126 exceto
														// o 34 ("), começando
														// com aspas duplas ou simples
	
	static final String lineCommentStart = "(//.*)"; // Início de comentário de
														// linha, "//"
	
	static final String inlineBlockComment = "(/\\*.*?\\*/)"; // Comentário de
																// bloco "/*
																// aaaa */"
	
	static final String blockCommentStart = "(/\\*.*)"; // Início de comentário
														// de bloco "/* aaaaa"
	
	static final String blockCommentEnd = "(.*?\\*\\/)"; // Fim de comentário de
															// bloco "aaaa */"

	public static LexIO removeComments(LexIO io) {
		// TODO Auto-generated method stub
		return null;
	}

	public static LexIO removeWhitespace(LexIO io) {
		// TODO Auto-generated method stub
		return null;
	}

	/**
	 * Remove o lixo do código: Comentários, strings não fechadas e caracteres constantes não fechados
	 * 
	 * @param io
	 * @return
	 */
	public static LexIO removeTrash(LexIO io) {

		LexIO lexOut = new LexIO(io);
		String[] lines = io.getLines();
		String lineCommentsPattern;
		String openCommentPattern;

		boolean isBlockCommentOpen = false;
		int lineNumber = 0;

		String allStrings = validStrings + "|" + openStrings;

		for (String line : lines) {
			 System.out.println("Line: " + line);
			Pattern pattern = Pattern.compile(allStrings);
			Matcher matcher = pattern.matcher(line);
			while (matcher.find()) {
				if (matcher.group(2) != null) {
					lines[lineNumber] = line.replace(matcher.group(2), "");
				}
			}
			lineNumber++;
		}
		
		/*
		 * Comentários de linha podem ser // desde que não exista um comentário
		 * aberto antes
		 * 
		 * Comentários de linha também não são considerados dentro de strings
		 * válidas Como a engine é gulosa, um match na string é suficiente.
		 * 
		 * Este while alterna entre dois estados: comentário aberto / comentário
		 * fechado 
		 * No comentário fechado, ele tenta dar match em 3 possíveis
		 * combinações: 
		 * -Comentário de bloco em linha; 
		 * -Comentário de linha usando //;
		 * -Início de comentário de bloco
		 * 
		 * 
		 * No comentário aberto, ele consome as linhas seguintes até encontrar
		 * um padrão de fechar comentário de bloco
		 * 
		 */

		lineCommentsPattern = validStrings + "|" + inlineBlockComment + "|" + lineCommentStart + "|"
				+ blockCommentStart;

		openCommentPattern = blockCommentEnd + "|" + "(^.*?$)";
		lineNumber = 0;
		while (lineNumber < lines.length) {
			StringBuilder builder = new StringBuilder(lines[lineNumber]);
			Pattern pattern;
			boolean skipLine = true;
			if (isBlockCommentOpen)
				pattern = Pattern.compile(openCommentPattern);
			else
				pattern = Pattern.compile(lineCommentsPattern);

			Matcher matcher = pattern.matcher(lines[lineNumber]);

			System.out.println("Trying to match line " + lineNumber
					+ (isBlockCommentOpen ? " with comments " : " without comments"));
			while (matcher.find()) {
				
				// Comentário de bloco aberto
				
				if (isBlockCommentOpen) {
					if(matcher.group(1) != null) {
						System.out.println(lineNumber + ": replacing block comment end: " + matcher.start() + "  "
								+ matcher.end() + " " + matcher.group(1));
					isBlockCommentOpen = false;
					skipLine = false;
					}
				}
				
				// Comentário de bloco fechado
				
				else if (matcher.group(1) != null) {
					System.out.println(lineNumber + ": matched valid string, dont touch it");
					continue;
				} else if (matcher.group(2) != null) {
					System.out.println(lineNumber + ": replacing inline block comment : " + matcher.start() + "  "
							+ matcher.end() + " " + matcher.group(2));
					skipLine = false;
				} else if (matcher.group(4) != null) {
					System.out.println(lineNumber + ": replacing comment start: " + matcher.group(4));
					isBlockCommentOpen = true;
				}
				
				lines[lineNumber] = builder.delete(matcher.start(), matcher.end()).toString();
				break;
			}
			if(skipLine)
				lineNumber++;
		}

		System.out.println("-----------------");

		for (String line : lines) {
			System.out.println(line);
		}

		lexOut.setLines(lines);

		return lexOut;
	}

	public static LexIO getValidTokens(LexIO io) {
		// TODO Auto-generated method stub
		return null;
	}

}
